## 现象与根因（基于日志与现有实现）

* 问题1（录制中启用补盲导致录制中断且无法恢复）有两条叠加根因：

  * MultiCameraManager 的“等待 Session 配置完成后启动录制”计数逻辑，会被补盲触发的 `recreateSession()` 再次触发 `onCameraConfigured()` 回调，从而**重复执行 pendingRecordingStart**。在 Codec 模式下这会导致：`startRecording()` 返回“Already recording”→被当成失败→MultiCameraManager 释放/停止 CodecVideoRecorder，直接把录制杀掉（日志里 `Attempting to start codec recording...` + `Already recording` + 随后 `Stopping codec recording` 能对应上）。

  * SingleCamera 的 session 失败/abandoned 恢复逻辑过于激进：`onConfigureFailed` 和 `IllegalArgumentException(abandoned)` 都会优先 `recordSurface=null` 并重试，导致 Camera2 停止向录制面送帧，录制链路进入不可恢复状态。

* 问题3（后台未录制时补盲窗无画面）与 MainActivity 的后台策略直接相关：`onPause()` 在“未录制”时会 `closeAllCameras()`（见 MainActivity.onPause），因此 BlindSpotService 虽能弹窗，但没有任何 camera session 在出帧。

## 修复步骤（先 1 后 2/3）

### 1) 先修复“录制中启用补盲导致录制中断”

* 改 MultiCameraManager：让“等待 Session 完成→启动录制”的状态只对**一次启动流程**有效，且启动成功后立即清理，避免被补盲/悬浮窗的 session 重建误触发。

  * 在 Codec 启动成功路径中，像 MediaRecorder 的 `executeRecordingStart()` 一样：

    * `pendingRecordingStart = null`

    * `sessionConfiguredCount = 0; expectedSessionCount = 0`

    * 取消 `sessionTimeoutRunnable`

  * 在 `onCameraConfigured()` 里：

    * 仅当 `expectedSessionCount > 0` 且该 cameraKey **本轮尚未标记 ready** 时才计数（避免同一摄像头因补盲重建 session 导致 `3/2、4/2` 这种超计数）。

  * 在 Codec 的 `pendingRecordingStart` runnable 里增加保护：

    * 若 `isRecording==true` 或 `codecRecorder.isRecording()==true`，视为已启动，不再走“失败→release”路径。

* 改 SingleCamera：把 session 失败/abandoned 的降级顺序从“先砍 recordSurface”改为“先砍可选预览面”。

  * `onConfigureFailed()`：如果同时存在 `secondaryDisplaySurface/mainFloatingSurface`，优先清掉它们并重试；只有当仍失败且确实需要降级时才考虑清 `recordSurface`。

  * catch `IllegalArgumentException`(abandoned)：优先尝试移除 secondary/main 浮窗 Surface 并重试；仅当确定录制面自身废弃时才清 `recordSurface`，并通过 callback/状态让上层触发录制重建。

### 2) 再修复“前台/后台补盲差异”（主要是问题3，同时巩固问题2）

* 最小改动方案（优先落地，风险低）：

  * MainActivity.onPause：当补盲相关功能开启（`isSecondaryDisplayEnabled`/`isMainFloatingEnabled`/`isTurnSignalLinkageEnabled`）时，不再无条件 `closeAllCameras()`；否则保持原逻辑。

  * BlindSpotService：在需要出画面前检测 `MainActivity.getInstance()` 与 `cameraManager.hasConnectedCameras()`，若未连接则触发 `openAllCameras()` 并做一次延迟重试绑定 Surface（避免 TextureView 尚未 ready）。

  * 确保后台出画面时 CameraForegroundService 在运行（必要时在 BlindSpotService.update/启动时调用 startForegroundService 的入口更新通知文案）。

* 中期重构方案（可选，与你的“剥离 camera service”建议一致）：

  * 把 MultiCameraManager/SingleCamera 的生命周期从 MainActivity 抽到一个前台服务（CameraForegroundService 或新 CameraService）中，Activity/BlindSpotService 通过 binder/单例接口获取 camera session 输出，避免 Activity 后台销毁/TextureView 生命周期影响补盲。

## 验证方式（每步都能回归）

* 针对问题1：

  * 录制进行中（MediaRecorder 与 Codec 两种模式各测一次）→ 发送 `BlindSpotService` 的 mock\_turn\_signal（left/right）→ 观察录制文件持续增长、无“stop codec recording / release recorder / recordSurface cleared”类日志。

  * 补盲结束（熄灭）→ 录制仍持续，且后续手动 stop/start 录制可恢复。

* 针对问题3：

  * 不录制→按 Home 让 App 后台→触发补盲→副屏/悬浮窗应出画面；关闭补盲后可按策略决定是否关闭相机。

## 风险与回退

* 变更集中在 MultiCameraManager/SingleCamera 的状态机与降级策略，属于“控制流修复”，风险主要是边界条件（并发重建、超时）。会保留原日志并新增关键状态日志，便于现场定位。

* 若目标硬件确实不支持录制时额外预览输出，将提供“录制优先”的降级：录制不中断，但补盲在录制时可能暂时不出画面（或退化为低帧率 bitmap

